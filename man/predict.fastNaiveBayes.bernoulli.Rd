% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.fastNaiveBayes.bernoulli.R
\name{predict.fastNaiveBayes.bernoulli}
\alias{predict.fastNaiveBayes.bernoulli}
\title{Predict Method for fastNaiveBayes.bernoulli fits}
\usage{
\method{predict}{fastNaiveBayes.bernoulli}(object, newdata,
  type = c("class", "raw", "rawprob"), sparse = FALSE,
  threshold = .Machine$double.eps, ...)
}
\arguments{
\item{object}{A fitted object of class "fastNaiveBayes.bernoulli".}

\item{newdata}{A numeric matrix with 1's and 0's to indicate the presence or absence of features. A Sparse dgcMatrix is also accepted.
Note that if newdata contains features that were not encountered in the training data, these are omitted from the prediction.
Furthermore, newdata can contain fewer features than encountered in the training data. In this case, newdata will be padded with
extra columns all filled with 0's.}

\item{type}{If "raw", the conditional a-posterior probabilities for each class are returned, and the class with maximal probability else.}

\item{sparse}{Use a sparse matrix? If true a sparse matrix will be constructed from x.
It's possible to directly feed a sparse dgcMatrix as x, which will set this parameter to TRUE}

\item{threshold}{A threshold for the minimum probability. For Bernoulli and Multinomial event models Laplace smoothing solves this,
but in the case of Gaussian event models, this ensures numerical probabilities}

\item{...}{Not used.}
}
\value{
If type = 'class', a factor with classified class levels. If type = 'raw', a matrix with the predicted probabilities of
    each class, where each column in the matrix corresponds to a class level.
}
\description{
Uses a fastNaiveBayes.bernoulli model and a new data set to create the classifications.
    This can either be the raw probabilities generated by the fastNaiveBayes.bernoulli model or the classes themselves.
}
\details{
In the extremely unlikely case that two classes have the exact same estimated probability, the first encountered class
    is used as the classification.

    Using a sparse matrix directly can be especially useful if it's necessary to use predict multiple times on the same matrix or
    on different subselections of the same initial matrix, see examples for further details.
}
\examples{
rm(list = ls())
library(fastNaiveBayes)

cars <- mtcars
y <- as.factor(ifelse(cars$mpg > 25, "High", "Low"))
x <- cars[, 2:ncol(cars)]

dist <- fastNaiveBayes::fastNaiveBayes.detect_distribution(x, nrows = nrow(x))

# Bernoulli only
vars <- c(dist$bernoulli, dist$multinomial)
newx <- x[, vars]
for (i in 1:ncol(newx)) {
  newx[[i]] <- as.factor(newx[[i]])
}
new_mat <- model.matrix(y ~ . - 1, cbind(y, newx))
mod <- fastNaiveBayes.bernoulli(new_mat, y, laplace = 1)
pred <- predict(mod, newdata = new_mat)
mean(pred != y)
}
